;; This file contains some utility emacs code for easier adaption of
;; source code into TeX documents.

(defun ttl-index-entry (s)
  (interactive "sEntry: ")
  (insert "%\n\\index{")
  (insert s)
  (insert "}"))

(defun ttl-variablify-region (beg end)
  (interactive "r")
  (save-excursion
    (goto-char end)
    (insert "$")
    (goto-char beg)
    (insert "$")))

(defun ttl-texify-region (beg end)
  (interactive "r")
  (save-excursion
    (save-restriction
      (narrow-to-region beg end)
      (untabify (point-min) (point-max))
      (let ((rep
	     '(("and" . "\\ttlAnd{}")
	       ("array" . "\\ttlArray{}")
	       ("constraint" . "\\ttlConstraint{}")
	       ("const" . "\\ttlConst{}")
	       ("datatype" . "\\ttlDatatype{}")
	       ("do" . "\\ttlDo{}")
	       ("else" . "\\ttlElse{}")
	       ("elseif" . "\\ttlElseif{}")
	       ("end" . "\\ttlEnd{}")
	       ("export" . "\\ttlExport{}")
	       ("false" . "\\ttlFalse{}")
	       ("fun" . "\\ttlFun{}")
	       ("hd" . "\\ttlHd{}")
	       ("if" . "\\ttlIf{}")
	       ("in" . "\\ttlIn{}")
	       ("import" . "\\ttlImport{}")
	       ("list" . "\\ttlList{}")
	       ("module" . "\\ttlModule{}")
	       ("not" . "\\ttlNot{}")
	       ("null" . "\\ttlNull{}")
	       ("of" . "\\ttlOf{}")
	       ("or" . "\\ttlOr{}")
	       ("out" . "\\ttlOut{}")
	       ("prefer" . "\\ttlPrefer{}")
	       ("require" . "\\ttlRequire{}")
	       ("retract" . "\\ttlRetract{}")
	       ("retract" . "\\ttlRetract{}")
	       ("return" . "\\ttlReturn{}")
	       ("string" . "\\ttlString{}")
	       ("tl" . "\\ttlTl{}")
	       ("then" . "\\ttlThen{}")
	       ("true" . "\\ttlTrue{}")
	       ("type" . "\\ttlType{}")
	       ("var" . "\\ttlVar{}")
	       ("public" . "\\ttlPublic{}")
	       ("while" . "\\ttlWhile{}")))
	    (rep1
	     '(
	       (">=" . "$\\geq$")
	       ("<=" . "$\\leq$")
	       ("<>" . "$\\neq$")
	       ("<" . "$<$")
	       (">" . "$>$")
	       ("-" . "$-$")
	       ("+" . "$+$")
	       ("_" . "\\_")
	       ("!" . "{\\bf!}")
	       (":=" . "$\\leftarrow$"))))

	(while rep
	  (perform-replace (caar rep) (cdar rep)
			   (point-min) (point-max)
			   nil nil t)
	  (setq rep (cdr rep)))
	(while rep1
	  (perform-replace (caar rep1) (cdar rep1)
			   (point-min) (point-max)
			   nil nil nil)
	  (setq rep1 (cdr rep1))))
      (goto-char (point-min))
      (let ((x 1))
	(while (< (point) (point-max))
	  (beginning-of-line)
	  (let ((empty (looking-at "[ \t]*$")))
	    (if (not empty)
		(progn
		  (while (looking-at "  ")
		    (delete-char 2)
		    (insert "\\>"))
		  (beginning-of-line)
		  (insert (format "%s\\>" x))
		  (setq x (+ x 1))))
	    (end-of-line)
	    (insert "\\\\")
	    (next-line 1))))
      (goto-char (point-min))
      (insert "\\begin{ttlprog}\n")
      (goto-char (point-max))
      (insert "\\end{ttlprog}\n"))))

(defun turtledoc-update-region (beg end)
  (interactive "r")
  (shell-command-on-region beg end "./update-module-node.sh" t t))
;  (texinfo-all-menus-update t))

(defun turtledoc-update-current-node (&optional arg)
  (interactive "P")
  (if (looking-at "^@node ")
      nil
    (re-search-backward "^@node "))
  (beginning-of-line)
  (let ((start (point)))
    (end-of-line)
    (re-search-forward "^@node ")
    (beginning-of-line)
    (previous-line 1)
    (if (looking-at "@c")
	(previous-line 1))
    (let ((end (point)))
      (turtledoc-update-region start end)
      (if arg (texinfo-all-menus-update t)))))

(defvar turtledoc-window-configuration nil)
(defvar turtledoc-last-comment-was-c-style nil)

(defun turtledoc-edit-region (beg end)
  (interactive "r")
  (setq turtledoc-docstring-beginning beg)
  (setq turtledoc-docstring-end end)
  (let ((doc (buffer-substring beg end)))
    (setq turtledoc-window-configuration (current-window-configuration))
    (with-current-buffer (get-buffer-create "*turtledoc*")
      (erase-buffer)
      (insert doc)
      (goto-char (point-min))
      (if (looking-at "//\\*[ \t]*")
	  (while (not (eobp))
	    (if (looking-at "//\\*[ \t]*")
		(delete-region (match-beginning 0) (match-end 0)))
	    (forward-line))
	(if (looking-at "/\\*\\*[ \t]*")
	    (progn
	      (delete-region (match-beginning 0) (match-end 0))
	      (forward-line)
	      (while (not (eobp))
		(if (looking-at "[ \t]*")
		    (delete-region (match-beginning 0) (match-end 0)))
		(forward-line))
	      (if (re-search-backward "\\*/" nil t)
		  (delete-region (match-beginning 0) (match-end 0))))))
      (goto-char (point-min))
      (texinfo-mode)
      (if global-font-lock-mode
	  (font-lock-fontify-buffer))
      (local-set-key "\C-c\C-c" 'turtledoc-edit-finish)
      (setq fill-column 63)
      (switch-to-buffer-other-window (current-buffer))
      (message "Type `C-c C-c' to finish"))))
  
(defun turtledoc-edit-finish ()
  (interactive)
  (goto-char (point-min))
  (if (eobp)
      nil
    (if turtledoc-last-comment-was-c-style
	(progn
	  (insert "/** ")
	  (forward-line 1)
	  (while (not (eobp))
	    (insert "    ")
	    (forward-line 1))
	  (previous-line 1)
	  (end-of-line)
	  (insert "*/"))
      (while (not (eobp))
	(insert "//* ")
	(forward-line 1))))
  (let ((doc (buffer-string)))
    (kill-buffer (current-buffer))
    (set-window-configuration turtledoc-window-configuration)
    (let ((region (turtledoc-find-docstring)))
      (if region
	  (progn
	    (goto-char (car region))
	    (delete-region (car region) (cdr region)))
	(error "Docstring disappeared!"))
      (insert doc))))

(defun turtledoc-edit-documentation ()
  (interactive)
  (let ((region (turtledoc-find-docstring)))
    (if region
	(turtledoc-edit-region (car region) (cdr region))
      (error "No docstring!"))))

(defun turtledoc-find-docstring ()
  (save-excursion
    (beginning-of-line)
    (if (looking-at "//\\*")
	(progn
	  (while (and (not (bobp)) (looking-at "//\\*"))
	    (previous-line 1))
	  (if (not (looking-at "//\\*"))
	      (next-line 1))
	  (let ((beg (point)))
	    (while (and (not (eobp)) (looking-at "//\\*"))
	      (next-line 1))
	    (let ((end (point)))
	      (setq turtledoc-last-comment-was-c-style nil)
	      (cons beg end))))
      (if (or (looking-at "/\\*\\*") (re-search-backward "^/\\*\\*" nil t))
	  (let ((beg (point)))
	    (if (re-search-forward "\\*/[ \t]*$" nil t)
		(progn
		  (forward-char 1)
		  (let ((end (point)))
		    (setq turtledoc-last-comment-was-c-style t)
		    (cons beg end)))))))))

(defvar turtle-manual-name "/home/mgrabmue/diplom/turtle/doc/turtle.texi")

(defun turtledoc-update-manual ()
  "Find the Turtle manual and search for the node documenting the module
in the current buffer.  Then update that node with the documentation
from the module source file."
  (interactive)
  (save-some-buffers)
  (save-excursion
    (beginning-of-buffer)
    (if (re-search-forward "^module \\([A-Za-z0-9_.]+\\)" nil t)
	(let ((module-name (buffer-substring (match-beginning 1)
					     (match-end 1))))
	  (let ((manual-buffer (find-file-noselect turtle-manual-name)))
	    (with-current-buffer manual-buffer
	      (beginning-of-buffer)
	      (if (re-search-forward (concat "^@node " module-name " module")
				     nil t)
		  (progn
		    (turtledoc-update-current-node 1))
;		    (save-some-buffers))
		(error "No documentation for this module in manual")))))
      (error "No module name"))))

(require 'turtle-mode)

(define-key turtle-mode-map "\C-c\C-t\C-e" 'turtledoc-edit-documentation)
(define-key turtle-mode-map "\C-c\C-t\C-u" 'turtledoc-update-manual)

(provide 'turtle-utils)
